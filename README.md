final assignment for prima



| Nr | Bezeichnung           | Inhalt                                                                                                                                                                                                                                                                         |
|---:|-----------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    | Titel                 | Platform Editor
|    | Name                  | Robin Schwab
|    | Matrikelnummer        | 256325
|  1 | Nutzerinteraktion     | Im Editor: Navigieren der Szene über Shift + Mausbewegen / Objekte zur Szene hinzufügen über Mausklick / Objekte verschieben mit Drag and Drop (zum Grid snappen über Ctrl-links) / Selektierte Objekte entfernen über delete / Aktionen rückgängig machen über Ctrl + Z (experimentell). ///// Im Game: Bewegen über a/d oder linke/rechte Pfeiltasten / Springen mit Leertaste / Musik stummschalten mit m |
|  2 | Objektinteraktion     | Es wird jeden Frame überprüft ob der Spieler eine Bewegung nach unten vollzieht, wenn er dabei mit dem Boden kollidieren würde, wird er nach oben translatiert. Außerdem wird geschaut, ob der Charakter mit einem Gegner kollidiert; wenn er von oben mit dem Gegner kollidiert, wird der Gegner entfernt, ansonsten hat man das Spiel verloren und der Game-Loop wird beendet.|
|  3 | Objektanzahl variabel | Es wird immer im Editor ein neues Objekt erzeugt, sobald der Nutzer ein Objekt zur Szene hinzugefügt hat. Dabei wird einfach ein neues Objekt erzeugt, das die gleiche Translation hat wie das vorherige Objekt.     |                                                                                                                                         
|  4 | Szenenhierarchie      | Die Szenenhierarchie ist sinnvoll aufgebaut. Wer ist wessen Parent, wie sind Elemente in anderen gruppiert und warum?                                                                                                                                                          |
|  5 | Sound                 | Eine Hintergrundmusik ist eingebunden, die für eine fröhliche Atmosphäre sorgen soll. Außerdem werden jeweils Sounds abgespielt, wenn 1)  der Spieler einen Gegner besiegt 2) der Spieler von einem Gegner besiegt wird 3) das Spiel beendet wird. |
|  6 | GUI                   | Der Nutzer durch ein graphisches Interface neue Objekte zur Szene hinzufügen und diese an die richtige Stelle ziehe, um so interaktive Level zu erzeugen. Hier können durch Klicken neue Element hinzugefügt werden, vorhandene Objekte verschoben und entfernt werden sowie Aktionen rückgängig gemacht werden. Außerdem gibt es die Möglichkeit, Level über einen Button zu speichern und diese wieder zu laden.         |                                                                         
|  7 | Externe Daten         | Die erstellten Levels werden in einer externen json-Datei gespeichert, dieses Level wird im Spiel dann wieder geladen. Damit können ganze Level über externe Daten erzeugt werden.                                                                                  |
|  8 | Verhaltensklassen     | In der Player Klasse wird definiert, wie der Spieler sich bewegt und mit Objekten interagiert (Kollision mit Boden/Gegnern). Außerdem werden dort Sprite-Animationen generiert. In der Enemy Klasse werden ebenfalls Sprite-Animationen generiert, außerdem wird  das das bei Programmstart näheste Bodenobjekt gesucht und alle benachbarten Bodenobjekte speichern, sodass der Gegner sich in konstanter Zeit über den Boden bewegen kann. Zudem wird ist in vielen Klassen definiert, wie diese sich erzeugen und serialisieren/deserialisieren.                                                                                              |
|  9 | Subklassen            | Ein Interface PickableNode erbt von f.Node und definiert Funktionalitäten, die für das Picking wichtig sind. Die Klassen, die dieses Interface implementieren, verfügen somit über einheitliche Node Funktionen sowie Picking-Funktionen. Die Enemy und Player Klassen erben außerdem von fAid.NodeSprite und erhalten damit Funktionen zum Anzeigen und Animieren von Sprites.  |
| 10 | Maße & Positionen     | Maße, Skala und Positionen sind gut durchdacht. Wie groß sind Spielfiguren, wie ist die Welt angeordnet bezogen auf den Ursprung, wie sind Spielelemente bezogen auf ihre lokalen Koordinatensysteme definiert?                                                                |
| 11 | Event-System          | Es werden eine Vielzahl von Events aufgelöst. Die viewports im Editor verfügen für die Interaktion über Keyboard und Mouseevent Listener. Außerdem werden die Events zum Aurufen von update-Funktionen in jedem Schleifendurchlauf benutzt.                                                                                                                                                                                 |
